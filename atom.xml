<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen Tang&#39;s Blog</title>
  <subtitle>生存以上，生活以下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://allen286.github.io/"/>
  <updated>2017-07-06T08:31:24.025Z</updated>
  <id>http://allen286.github.io/</id>
  
  <author>
    <name>Allen Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站前端性能优化</title>
    <link href="http://allen286.github.io/2017/07/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%960706/"/>
    <id>http://allen286.github.io/2017/07/06/性能优化0706/</id>
    <published>2017-07-06T08:58:44.000Z</published>
    <updated>2017-07-06T08:31:24.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、css，js加载和阻塞"><a href="#1、css，js加载和阻塞" class="headerlink" title="1、css，js加载和阻塞"></a>1、css，js加载和阻塞</h3><p><code>CSS</code>被认为是一种渲染阻塞资源（render blocking），同时CSS还会导致脚本阻塞，这是由于JavaScript文件必须等待CSSOM构建结束之后才进行执行。 </p>
<blockquote>
<p>与HTML不同，CSS具有层叠继承的特性，因此不能进行局部加载。定义在文档后面的样式属性会覆盖或更改写之前定义的同类属性。即如果CSS可以进行局部加载的话会导致出现加载错样式的情况，因此CSS必须全部解析之后才能进行下一步。  </p>
</blockquote>
<p><code>JavaScript</code>被认为是解析阻塞资源（block parse），当解析HTML文档自身时候会被JavaScript给阻塞掉，所以最佳实践建议script标签放body后面。<br>为避免JavaScript解析阻塞，可以设置<code>async</code>属性异步加载或者<code>defer</code>延迟加载。  </p>
<p><strong>async与defer区别和联系：</strong>   </p>
<ul>
<li>defer和async下载都是异步的，但执行时机不同。  </li>
<li>async不能保证加载顺序，在加载(download)完后立即执行；  </li>
<li>defer会按照加载顺序执行，同时在html parse完后才执行，即DOMContentLoaded 事件触发后执行。<br>但实际情况下，defer延迟脚本不一定按照先后顺序执行？待验证……  </li>
</ul>
<p><strong>举个栗子：</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//ms0.meituan.net/css/eve.9d9eee71.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">onload</span>=<span class="string">"MT.pageData.eveTime=Date.now()"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">window</span>.fk = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="built_in">require</span>([<span class="string">'util/native/risk.js'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">risk</span>) </span>&#123;</div><div class="line">      risk.getFk(callback);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>通常情况下，上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析：  </p>
<ul>
<li>CSS不会阻止页面继续向下继续。</li>
<li>内联的JS很快执行完成，然后继续解析文档。<br>然而，当这两部分同时出现的时候，问题就来了。</li>
</ul>
<p>通常情况下，CSS只会阻塞renderTree的构建，但并不会阻塞HTML的解析(parse)，但如果CSS后面有JS，则会<code>阻塞JS的执行</code>直到CSS加载完成（即便JS是内联的脚本），从而<code>间接阻塞HTML的解析</code>。一个小小的内联JS放错位置也会让性能下降很多。  </p>
<p><strong>如何优化？</strong>  </p>
<ul>
<li>CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。</li>
<li>但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。</li>
<li>如果必须要在头部增加内联脚本，一定要放在CSS标签之前。 </li>
</ul>
<p>参考资料：<a href="http://tech.meituan.com/WebViewPerf.html" target="_blank" rel="external">美团点评技术团队：WebView性能、体验分析与优化</a></p>
<h3 id="2、前端性能优化"><a href="#2、前端性能优化" class="headerlink" title="2、前端性能优化"></a>2、前端性能优化</h3><p>Udacity有两个很不错的免费课程：<br><a href="https://cn.udacity.com/course/website-performance-optimization--ud884/" target="_blank" rel="external">网站性能优化</a><br><a href="https://cn.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="external">浏览器渲染优化</a>  </p>
<p>以及老生常谈的<a href="https://stevesouders.com/hpws/rules.php" target="_blank" rel="external">雅虎14条</a><br>重要的是先分析性能瓶颈在哪，是DNS慢，还是后端接口返回慢，还是js及css资源加载及执行耗时过多等等，再有针对性的优化，善用Chrome DevTools，其中的network，timeline和performance等都是很强大的工具。 </p>
<h4 id="关键路径渲染（CRP-Critical-Rendering-Path）"><a href="#关键路径渲染（CRP-Critical-Rendering-Path）" class="headerlink" title="关键路径渲染（CRP, Critical Rendering Path）"></a>关键路径渲染（CRP, Critical Rendering Path）</h4><blockquote>
<p>从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么 - 即关键渲染路径  </p>
</blockquote>
<p>过程：DOM Tree -&gt; CSSOM Tree -&gt; Render Tree -&gt; Layout -&gt; Paint，略去了js执行部分(Evaluate Script)及其相互间影响，当然前面还有requesting和loading的过程，然后才parse解析。  </p>
<p><strong>什么是CRP长度？</strong>  </p>
<blockquote>
<p>获取所有阻塞资源（关键资源）所需的往返次数，比如说样式文件，脚本文件。（图片不属于关键资源，因为图片不会导致阻塞游览器渲染）</p>
</blockquote>
<p><strong>CRP 中几个关键的时间点：</strong>  </p>
<blockquote>
<p>domLoading： 这是整个 CRP 的开始的时间点。<br>domInteractive： 游览器刚好构建完 DOM 的时间点。<br>domContentLoaded： DOM构建完成，且没有任何<strong>样式</strong>会阻塞脚本运行的时间点。意思就是当没有脚本文件执行的时候，DOM 构建完成时就到达这个时间点，不过这种情况很少见，当有脚本文件要执行的时候，样式（CSSOM）会阻塞脚本文件执行，此时要等到样式全部就绪的时候才会到达这个时间点。所以，当存在脚本文件的时候，一般domContentLoaded会往后推移许多。<br>domCompelete： 表示所有资源都已经下载完成，包括图片，字体等。这个时间点将触发onload事件。  </p>
</blockquote>
<p>其中要重点关注下domContentLoaded，jQuery的 $(document).ready() 方法，就是对DOMContentLoaded事件的监听（当然，其内部还会通过模拟DOMContentLoaded事件和监听onload事件来提供降级方案）。<br>拓展阅读：<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" target="_blank" rel="external">AlloyTeam：DOMContentLoaded事件探究</a></p>
<p><strong>优化关键渲染路径：</strong><br>关键词：资源数、字节数、长度。  </p>
<ul>
<li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</li>
<li>优化关键字节数以缩短下载时间（往返次数）。</li>
<li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</li>
</ul>
<h4 id="回流-reflow-与重绘-repaint"><a href="#回流-reflow-与重绘-repaint" class="headerlink" title="回流(reflow)与重绘(repaint)"></a>回流(reflow)与重绘(repaint)</h4><p>顾名思义，重绘只是重新进行paint过程，而回流是布局有变化，要先重新layout再paint，故而开销比较大。<br>常见的会引起回流的操作及如何减少回流？具体不表。可参考<a href="http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="external">张鑫旭：回流与重绘：CSS性能让JavaScript变慢</a>  </p>
<p>需要注意的是，对于transform/opacity 这两种变换，浏览器不会用repaint/reflow处理，而是在已经渲染好的元素基础上进行附加工作，这就要提到compositor layer合成渲染层了。  </p>
<p>参考资料：<br><a href="http://wuduoyi.com/note/what-happen-when-browser-loading-the-page/" target="_blank" rel="external">浏览器的加载过程</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="https://zhuanlan.zhihu.com/p/23428399" target="_blank" rel="external">重绘，回流和合成，了解基本浏览器绘制帮你优化页面性能</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、css，js加载和阻塞&quot;&gt;&lt;a href=&quot;#1、css，js加载和阻塞&quot; class=&quot;headerlink&quot; title=&quot;1、css，js加载和阻塞&quot;&gt;&lt;/a&gt;1、css，js加载和阻塞&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;被认为是一种渲染阻塞
    
    </summary>
    
    
      <category term="javascript" scheme="http://allen286.github.io/tags/javascript/"/>
    
      <category term="性能" scheme="http://allen286.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>__proto__ 与prototype，defineProperty与双向绑定</title>
    <link href="http://allen286.github.io/2017/07/06/defineProperty0706/"/>
    <id>http://allen286.github.io/2017/07/06/defineProperty0706/</id>
    <published>2017-07-06T08:38:44.000Z</published>
    <updated>2017-07-06T08:32:10.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、proto-与prototype关系"><a href="#1、proto-与prototype关系" class="headerlink" title="1、proto 与prototype关系"></a>1、<strong>proto</strong> 与prototype关系</h3><p>先看段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> kitty = <span class="keyword">new</span> Animal(<span class="string">'kitty'</span>)</div><div class="line">Animal.prototype === kitty.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>对象<code>__proto__</code>属性的值就是它所对应的原型对象，每个对象都有<strong>proto</strong>属性来标识自己所继承的原型，但只有函数才有<code>prototype</code>属性。  </p>
<blockquote>
<p>当你创建函数时，JS会为这个函数自动添加prototype属性。而一旦你把这个函数当作构造函数（constructor）调用（即通过new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法（实例通过设置自己的<strong>proto</strong>指向承构造函数的prototype来实现这种继承）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.constructor === A <span class="comment">// true</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">a <span class="keyword">instanceof</span> A <span class="comment">// true</span></div><div class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>instanceof</code>操作符正是通过探测<code>obj.__proto__.__proto__... === Constructor.prototype</code>来验证obj是否是Constructor的实例的</p>
<h3 id="2、define-property，setter，getter"><a href="#2、define-property，setter，getter" class="headerlink" title="2、define property，setter，getter"></a>2、define property，setter，getter</h3><h4 id="首先区分访问器属性与数据属性"><a href="#首先区分访问器属性与数据属性" class="headerlink" title="首先区分访问器属性与数据属性"></a>首先区分访问器属性与数据属性</h4><p><strong>数据属性：</strong><br>数据属性包含一个数据值的位置,在这个位置可以读取和写入值。<br>属性特性（property）：<code>configurable</code>,<code>enumerable</code>,<code>writable</code>,<code>value</code><br>通过new Object或对象字面量创建的对象，它们属性的 [[Configurable]]、[[Enumerable]] 和 [[Writable]] 特性默认都被设置为 true，而 [[Value]] 特性被设置为指定的值。要修改属性默认的特性，必须使用 ECMAScript 的 Object.defineProperty() 方法。  </p>
<pre><code class="javascript"><span class="keyword">var</span> a={<span class="attr">x</span>:<span class="number">1</span>};
<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(a,<span class="string">'x'</span>))
<span class="comment">// Object {value: 1, writable: true, enumerable: true, configurable: true}</span>
<span class="keyword">var</span> person = {};
<span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,{
  <span class="attr">value</span>: <span class="string">"percy"</span>
});
<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>));
<span class="comment">// Object {value: "percy", writable: false, enumerable: false, configurable: false}</span>
</code></pre>
<p><strong>访问器属性：</strong><br>访问器属性不包含数据值，它们包含一对getter和setter函数，在读取访问器属性时会调用getter函数，在写入访问器属性时会调用 setter函数并传入新值。<br>属性特性（property）： <code>configurable</code>，<code>enumerable</code>，<code>set</code>，<code>get</code><br>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</p>
<p>ES5有三个操作会忽略enumerable为false的属性。</p>
<ol>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ol>
<blockquote>
<p>“访问器属性会优先访问，同名属性被忽略，即所谓的被<code>劫持</code>” </p>
</blockquote>
<p>实测了下，会将之前定义好的同名数据属性define为访问器属性，直接console将不会看到改属性，属性值也变为get函数中新定义的值。重新define value又可变回数据属性，但要注意数据描述符<code>value, writable</code>和访问描述符<code>set, get</code>,不能同时用，<br>会报错<code>invalid property descriptor. Cannot both specify accessors and a value or writable attribute.</code></p>
<h4 id="拓展：vue双向绑定的实现"><a href="#拓展：vue双向绑定的实现" class="headerlink" title="拓展：vue双向绑定的实现"></a>拓展：vue双向绑定的实现</h4><p><strong>关键词：</strong> 访问器属性（数据劫持），发布订阅者模式<br>通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>几个关键部分：监听器Observer，指令解析器Compile，Watcher连接Observer和Compile<br>简单实现可参考：<br><a href="https://juejin.im/entry/583bd53ca22b9d006dce11d7" target="_blank" rel="external">Vue.js双向绑定的实现原理</a> ,<br><a href="https://github.com/DMQ/mvvm" target="_blank" rel="external">自己动手实现双向绑定</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、proto-与prototype关系&quot;&gt;&lt;a href=&quot;#1、proto-与prototype关系&quot; class=&quot;headerlink&quot; title=&quot;1、proto 与prototype关系&quot;&gt;&lt;/a&gt;1、&lt;strong&gt;proto&lt;/strong&gt; 与
    
    </summary>
    
    
      <category term="javascript" scheme="http://allen286.github.io/tags/javascript/"/>
    
      <category term="Vue" scheme="http://allen286.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js数组本质</title>
    <link href="http://allen286.github.io/2017/04/10/js%E6%95%B0%E7%BB%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://allen286.github.io/2017/04/10/js数组本质/</id>
    <published>2017-04-10T14:10:22.000Z</published>
    <updated>2017-04-10T14:33:46.516Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个诡异的事情<br><code>let arr = []</code><br><code>arr.length = 9</code><br>对arr进行forEach循环时，一次循环也不会执行，等价于空数组。</p>
<p>上面方式等价于<code>let arr = new Array(9)</code></p>
<p>测试如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> array1 = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</div><div class="line">array   <span class="comment">//[undefined × 3]</span></div><div class="line">array1 <span class="comment">//[undefined, undefined, undefined]</span></div><div class="line"><span class="built_in">console</span>.log(array);  <span class="comment">//[]</span></div><div class="line"><span class="built_in">console</span>.log(array1); <span class="comment">//[undefined, undefined, undefined]</span></div><div class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="built_in">console</span>.log(item)&#125;); <span class="comment">//nothing output</span></div><div class="line">array1.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="built_in">console</span>.log(item)&#125;); <span class="comment">//undefined 3 times</span></div></pre></td></tr></table></figure></p>
<p>即js数组本质就是对象，给它添加length属性后，依旧没有存储任何值，和存undefined还是不一样的吧。。<br>但是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array[<span class="number">0</span>] <span class="comment">//undefined</span></div><div class="line">array[<span class="number">1</span>] <span class="comment">//undefined</span></div><div class="line">array[<span class="number">2</span>] <span class="comment">//undefined</span></div><div class="line">array[<span class="number">0</span>] === array1[<span class="number">0</span>] <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>由于无法forEach，最后采用了<code>Array.from(new Array(9), (v, i) =&gt; (i + 1))</code>的方法创建数组，通过设置mapFn参数，可填充任意值。<br>直接<code>new Array(9)).map( (v, i) =&gt; (i + 1))</code>不会执行循环，不会输出任何东西，为什么Array.from的时候mapFn就能map了？<br>觉得跟<code>类数组</code>相关，有length属性的对象，可以当做类数组转化为数组<br>测试了下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=&#123;<span class="attr">length</span>: <span class="number">9</span>&#125;</div><div class="line"><span class="built_in">Array</span>.from(a, (v, i) =&gt; (i + <span class="number">1</span>)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div></pre></td></tr></table></figure></p>
<p>正好验证了这个想法，<code>new Array(9)</code>或<code>let arr = []；arr.length = 9</code>这种方式创建的依然是个空数组，只是有length属性的空数组而已</p>
<p>快速创建数组的方法总结：<br>参考<a href="https://segmentfault.com/q/1010000007496752" target="_blank" rel="external">https://segmentfault.com/q/1010000007496752</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个诡异的事情&lt;br&gt;&lt;code&gt;let arr = []&lt;/code&gt;&lt;br&gt;&lt;code&gt;arr.length = 9&lt;/code&gt;&lt;br&gt;对arr进行forEach循环时，一次循环也不会执行，等价于空数组。&lt;/p&gt;
&lt;p&gt;上面方式等价于&lt;code&gt;let arr
    
    </summary>
    
    
      <category term="javascript" scheme="http://allen286.github.io/tags/javascript/"/>
    
      <category term="总结" scheme="http://allen286.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数组" scheme="http://allen286.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Git基础命令与实战问题记录</title>
    <link href="http://allen286.github.io/2017/03/17/Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://allen286.github.io/2017/03/17/Git基础/</id>
    <published>2017-03-17T07:10:22.000Z</published>
    <updated>2017-03-17T07:38:59.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础命令"><a href="#一、基础命令" class="headerlink" title="一、基础命令"></a>一、基础命令</h3><h4 id="1-检出仓库"><a href="#1-检出仓库" class="headerlink" title="1 检出仓库"></a>1 检出仓库</h4><p><code>git clone</code></p>
<h4 id="2-添加和提交"><a href="#2-添加和提交" class="headerlink" title="2 添加和提交"></a>2 添加和提交</h4><p><code>git add .</code>//提出更改（把它们添加到暂存区Index）<br><code>git commit  -m &#39;tag xxx&#39;</code> //实际提交改动并添加mark标记<br>现在改动已经提交到HEAD，但并未提交到远端仓库</p>
<h4 id="3-推送改动"><a href="#3-推送改动" class="headerlink" title="3 推送改动"></a>3 推送改动</h4><p><code>git push</code>  //需在后面添加远程分支名</p>
<h4 id="4-创建分支"><a href="#4-创建分支" class="headerlink" title="4 创建分支"></a>4 创建分支</h4><p><code>git checkout -b some_branch</code> //从当前分支创建分支并切换到该分支<br>相当于 <code>git branch some_branch</code>，<code>git checkout some_branch</code></p>
<h4 id="5-合并分支"><a href="#5-合并分支" class="headerlink" title="5 合并分支"></a>5 合并分支</h4><p><code>git merge</code>  //合并分支<br><code>git pull</code> //更新本地仓库至最新改动  </p>
<h5 id="git-fetch与git-pull区别？"><a href="#git-fetch与git-pull区别？" class="headerlink" title="git fetch与git pull区别？"></a>git fetch与git pull区别？</h5><p><code>git pull = git fetch + merge to local</code></p>
<h4 id="6-提PR"><a href="#6-提PR" class="headerlink" title="6 提PR"></a>6 提PR</h4><p>create pull request<br>提PR前先merge对应分支，解决冲突，<br>等同伴进行code review，根据别人的review重新修改代码，重新push，最后合代码</p>
<h3 id="二、如何将分支回滚到之前的某次commit？"><a href="#二、如何将分支回滚到之前的某次commit？" class="headerlink" title="二、如何将分支回滚到之前的某次commit？"></a>二、如何将分支回滚到之前的某次commit？</h3><p>之前遇到一个问题，想讲分支回滚到之前的某次commit，在sourceTree上reset后但是无法push。</p>
<p>最后用命令行，git checkout某个版本，然后git push –force解决的，但感觉这样很危险，不太好。</p>
<h4 id="git回滚到之前的某次commit"><a href="#git回滚到之前的某次commit" class="headerlink" title="git回滚到之前的某次commit"></a>git回滚到之前的某次commit</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>checkout回某分支，再强制push –force<br><code>git checkout 某次commit</code><br><code>git push -f origin master</code>  </p>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>回到之前的一个提交<br><code>git reset --hard HEAD^</code><br><code>git reset --hard 某次commit</code><br>将新的提交 强制推到 git 服务器上：<br><code>git push -f origin master</code></p>
<h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>revert。这样history log里面会有记录<br><code>git revert &lt;commit ID&gt;</code><br><code>git revert c011eb3</code>  </p>
<h5 id="git-revert-与-git-reset区别？"><a href="#git-revert-与-git-reset区别？" class="headerlink" title="git revert 与 git reset区别？"></a>git revert 与 git reset区别？</h5><p>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</p>
<h3 id="三、如何合并其他分支某次commit？"><a href="#三、如何合并其他分支某次commit？" class="headerlink" title="三、如何合并其他分支某次commit？"></a>三、如何合并其他分支某次commit？</h3><h5 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h5><p>直接 <code>git merge commit版本号</code>就行</p>
<h5 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h5><p><code>git checkout master</code><br><code>git cherry-pick commit-id1 commit-id2</code>  // 把指定commit合并到当前分支</p>
<h3 id="四、如何删除所有uncommit的文件修改"><a href="#四、如何删除所有uncommit的文件修改" class="headerlink" title="四、如何删除所有uncommit的文件修改?"></a>四、如何删除所有uncommit的文件修改?</h3><h5 id="法一：-1"><a href="#法一：-1" class="headerlink" title="法一："></a>法一：</h5><p>➜  develop git:(mta) ✗ <code>git stash</code><br>Saved working directory and index state WIP on mta: c43c984 revert again<br>HEAD is now at c43c984 revert again<br>➜  develop git:(mta) <code>git stash drop</code><br>Dropped refs/stash@{0} (619d4e0e14f11a4a9705080dcfe410155817f1b6)</p>
<h5 id="法二：-1"><a href="#法二：-1" class="headerlink" title="法二："></a>法二：</h5><p><code>git clean -df</code><br><code>git checkout --</code></p>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="http://stackoverflow.com/questions/52704/how-do-i-discard-unstaged-changes-in-git" target="_blank" rel="external">http://stackoverflow.com/questions/52704/how-do-i-discard-unstaged-changes-in-git</a><br><a href="http://stackoverflow.com/questions/4114095/how-to-revert-git-repository-to-a-previous-commit" target="_blank" rel="external">http://stackoverflow.com/questions/4114095/how-to-revert-git-repository-to-a-previous-commit</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、基础命令&quot;&gt;&lt;a href=&quot;#一、基础命令&quot; class=&quot;headerlink&quot; title=&quot;一、基础命令&quot;&gt;&lt;/a&gt;一、基础命令&lt;/h3&gt;&lt;h4 id=&quot;1-检出仓库&quot;&gt;&lt;a href=&quot;#1-检出仓库&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="git" scheme="http://allen286.github.io/tags/git/"/>
    
      <category term="总结" scheme="http://allen286.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="笔记" scheme="http://allen286.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记我的实习处女面</title>
    <link href="http://allen286.github.io/2016/10/12/firtInterview/"/>
    <id>http://allen286.github.io/2016/10/12/firtInterview/</id>
    <published>2016-10-12T03:38:37.000Z</published>
    <updated>2016-10-12T03:41:07.424Z</updated>
    
    <content type="html"><![CDATA[<p>昨天献出了自己实习处女面，回来后总结了下面试问题，与各位前端初学者共勉。</p>
<h4 id="1、浏览器内核，也就是渲染引擎"><a href="#1、浏览器内核，也就是渲染引擎" class="headerlink" title="1、浏览器内核，也就是渲染引擎"></a>1、浏览器内核，也就是渲染引擎</h4><p>火狐浏览器的<code>gecko</code>内核没答上，Opera从自家的<code>presto</code>内核后转投谷歌webkit也没答。<br>顺便补充下js引擎吧：chrome是<code>v8</code>，火狐是<code>JagerMonkey</code>，IE是 <code>Chakra</code>查克拉</p>
<h4 id="2、引入css几种形式？及其优先级顺序？"><a href="#2、引入css几种形式？及其优先级顺序？" class="headerlink" title="2、引入css几种形式？及其优先级顺序？"></a>2、引入css几种形式？及其优先级顺序？</h4><p>答了外部，嵌入，内联三种，其实还有外部除了<code>link</code>引入还有<code>@import</code>引入方式，漏掉了。<br>优先级是就近原则，级内联&gt;嵌入&gt;外部。<br>补充：<code>link</code>和<code>import</code>两种方式引入CSS的区别：</p>
<ul>
<li>　　区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>　　区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>　　区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>　　区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h4 id="3、position属性值有哪几种？及absolute是相对于什么进行定位？"><a href="#3、position属性值有哪几种？及absolute是相对于什么进行定位？" class="headerlink" title="3、position属性值有哪几种？及absolute是相对于什么进行定位？"></a>3、position属性值有哪几种？及absolute是相对于什么进行定位？</h4><p>没答出默认的static及sticky。<br><code>static | relative | absolute | fixed | sticky</code>(多数浏览器不支持，可忽略)<br>五种取值，其中<code>static</code>为默认值。另外inherit算不算？<br><code>absolute</code>相对于最近的<strong>非 static 定位祖先元素</strong>进行定位。定位元素（positioned element）是指计算后位置属性为<code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code>的元素。<br><code>fixed</code>，通过指定元素相对于屏幕视口（<code>viewport</code>）的位置来指定元素位置。  </p>
<h4 id="4、考察变量声明提升"><a href="#4、考察变量声明提升" class="headerlink" title="4、考察变量声明提升"></a>4、考察变量声明提升</h4><p>给了段代码让说输出会输出什么，为什么，以及在ES6中的差异。<br>挺简单的，略。不过跟ES6对比着说还是蛮有趣的。</p>
<h4 id="5、js中有哪几种数据类型？"><a href="#5、js中有哪几种数据类型？" class="headerlink" title="5、js中有哪几种数据类型？"></a>5、js中有哪几种数据类型？</h4><p>回答的是6种，即五种基本类型值+object。面试官补充说function也是。<br>但高程里说的是六种，function算到对象里了，虽然typeof操作符也能识别function。</p>
<h4 id="6、怎样识别数组？"><a href="#6、怎样识别数组？" class="headerlink" title="6、怎样识别数组？"></a>6、怎样识别数组？</h4><p>回答出三种：<code>instanceof</code>，<code>constructor</code>，<code>Object.prototye.toString()</code>；最后一种最稳定，推荐。<br>前两种方法在多个frame中穿梭时会出<a href="http://blog.csdn.net/lee_magnum/article/details/11555981" target="_blank" rel="external">问题</a><br>其实还有第四种：<code>Array.isArray()</code>，ES5中加入的方法，ie9+支持。  </p>
<p>回来后顺便学习了下<strong>instanceof操作符的原理</strong>，<code>a instanceof b</code>，本质是比较<code>a.__proto__与b.prototye</code>，而且是循环比较，不等时让<code>a=a.__proto__</code>继续比较，循环到底依然不相等则返回<code>false</code>。<br>循环到底也就是<code>到Object.prototype.__proto__=null</code>。<a href="http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/" target="_blank" rel="external">详见这里</a></p>
<h4 id="7、数组去重"><a href="#7、数组去重" class="headerlink" title="7、数组去重"></a>7、数组去重</h4><p>回答了5中方法：<code>indexOf</code>，<code>filter</code>，<code>hash</code>，<code>Object.keys()</code>，<code>ES6</code>的<code>Set</code>搭配<code>Array.from()</code>或拓展运算符<code>...</code><br>这个自我感觉回答的不错哈哈</p>
<h4 id="8、说说你遇到过的浏览器兼容性问题，以及怎么解决的？"><a href="#8、说说你遇到过的浏览器兼容性问题，以及怎么解决的？" class="headerlink" title="8、说说你遇到过的浏览器兼容性问题，以及怎么解决的？"></a>8、说说你遇到过的浏览器兼容性问题，以及怎么解决的？</h4><p>这个答的最差，平时自己练习不怎么考虑兼容性问题，对自己只要求支持ie9以上就行。回来想了想，还是踩过一小点坑的。  </p>
<h5 id="布局方面的兼容："><a href="#布局方面的兼容：" class="headerlink" title="布局方面的兼容："></a>布局方面的兼容：</h5><ul>
<li>用<code>:after</code>伪元素清除浮动时针对ie6，7需加<code>zoom：1</code>触发<code>hasLayout</code>；  </li>
<li>使用<code>header</code>，<code>footer</code>，<code>nav</code>等html5语义化标签时ie9一下不支持，尤其<code>nav</code>标签，以及通过某些hack方式可以让ie9以下支持html5标签；  </li>
<li><code>flex</code>布局ie10+才支持，CSS3属性需加上相应浏览器前缀或借助<code>autoprefixe</code>等css后处理器。  </li>
<li>那些<code>doctype</code>声明对布局的影响，什么触发标准模式之类的。这个我并不清楚，平时一直用html5的声明<code>&lt;!DOCTYPE html&gt;</code>，因为最简单。</li>
</ul>
<h5 id="js方面的兼容："><a href="#js方面的兼容：" class="headerlink" title="js方面的兼容："></a>js方面的兼容：</h5><ul>
<li>平稳退化及普通兼容js高程有介绍到一些，如事件的兼容；</li>
<li>数组的<code>forEach</code>，<code>filter</code>，<code>map</code>，<code>reduce</code>等ES5的遍历方法ie9一下不兼容，用普通for循环或者自己封装一个each函数，for循环为每个元素执行fn，数组项及数组索引作为fn参数；  </li>
<li>字符串去除首尾空格<code>trim()</code>，可以用自己写正则实现<code>replace(/^/s+|/s+$/g, &#39;&#39;)</code>  </li>
<li>数组的<code>indexOf</code>方法，<code>Object.keys()</code>方法，这些自己用过的ES5的方法，ie9以下不兼容。  </li>
<li><code>ES6</code>当然更不兼容了，所以压根没提。  </li>
<li>另外使用第三方库来解决兼容问题也是种很好的选择。  </li>
</ul>
<h4 id="9、问Ajax熟练程度"><a href="#9、问Ajax熟练程度" class="headerlink" title="9、问Ajax熟练程度"></a>9、问Ajax熟练程度</h4><p>由于只看书没写过就如实回答了，面试官建议装个服务器深入学习下<code>Ajax</code>，这方面蛮重要的。</p>
<h4 id="10、jQuery掌握程度，有什么作品"><a href="#10、jQuery掌握程度，有什么作品" class="headerlink" title="10、jQuery掌握程度，有什么作品"></a>10、jQuery掌握程度，有什么作品</h4><p>如实回答只看了<code>锋利的jQuery</code>一书，连练习都没做过，没有作品。。。</p>
<h4 id="11、实习生主要职责"><a href="#11、实习生主要职责" class="headerlink" title="11、实习生主要职责"></a>11、实习生主要职责</h4><p>包括移动端活动页面的制作，电脑端管理系统需求完善(<code>angular</code>)，甚至移动应用开发。然而这三者我都没接触过，计划<code>原生js</code>会再学习一段时间，同时强化下<code>ajax</code>，然后学习<code>http</code>协议，再然后才会学<code>MV**</code>之类的框架。</p>
<h4 id="12、加分项"><a href="#12、加分项" class="headerlink" title="12、加分项"></a>12、加分项</h4><p>一门后端语言，以及前端模块化方案，工程化构建工具这些我都没接触过。  </p>
<p>面试时间不长，大概二十多分钟，可能看我接触前端时间太短，基础不够没必要聊太多吧。面试官人很nice，感觉搞技术的人都很容易打交道。<br>总之面试问题还是很基础的，奈何自己基础不牢加紧张，表现很一般。正好也更认清了自己的水平，需要学习的东西还太多太多，再踏实学一段时间，打牢基础再出去实习吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天献出了自己实习处女面，回来后总结了下面试问题，与各位前端初学者共勉。&lt;/p&gt;
&lt;h4 id=&quot;1、浏览器内核，也就是渲染引擎&quot;&gt;&lt;a href=&quot;#1、浏览器内核，也就是渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;1、浏览器内核，也就是渲染引擎&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="总结" scheme="http://allen286.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="面试" scheme="http://allen286.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="实习" scheme="http://allen286.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ES6标准入门粗读</title>
    <link href="http://allen286.github.io/2016/10/11/es6/"/>
    <id>http://allen286.github.io/2016/10/11/es6/</id>
    <published>2016-10-11T14:05:37.000Z</published>
    <updated>2016-10-11T14:13:39.632Z</updated>
    
    <content type="html"><![CDATA[<p>为了面试，赶紧把ES6标准入门大致翻了一下，下面是一些要点笔记，很散很浅，以后再慢慢深入学习。</p>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>终于等来了块级作用域，但感觉以前学的好多的奇淫技巧可能以后就用不上了……</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><p>不存在变量提升，不允许重复声明let，const与块级作用域结合。<br>以后可以用let取代var了，全局变量优先用常量const。</p>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><p>这个蛮方便的，很强大，很多地方可以用到</p>
<h4 id="拓展运算符-…"><a href="#拓展运算符-…" class="headerlink" title="拓展运算符(…)"></a>拓展运算符(…)</h4><ol>
<li>拓展运算符+数组，用于将数组转化为，分割的的参数序列。  </li>
</ol>
<ul>
<li>可以用来替代apply传参，例如<code>Math.max(...[1,2,3,5]) //5</code></li>
<li>还可以用来合并数组，替代concat，例如<code>[1,2,...[3,4]] //[1, 2, 3, 4]</code></li>
<li>与解构赋值搭配使用例如<code>[first,...rest]=[1,2,3,4,5]//rest=[2,3,4,5]</code> </li>
</ul>
<ol>
<li>将字符串，类数组对象，Map及Set结构等具有iterator接口的对象转化为数组，<br>例如<code>[...&#39;haha&#39;] //[&quot;h&quot;, &quot;a&quot;, &quot;h&quot;, &quot;a&quot;]；[...arguments]；[...nodeList]；[...map.keys()]</code>  </li>
</ol>
<p><strong>rest参数</strong>，形式为“…变量名”，其实上面介绍拓展运算符时已经提到了。<br>如<code>function fn(...argname){}</code>，用于获取多与参数，把逗号隔开的值序列组合成一个数组，这样就不需要使用arguments对象了。<br><strong>注意</strong>：</p>
<ul>
<li>rest参数后面不能再有其他属性，不然会报错。<code>function(...a,b){} //error</code></li>
<li>函数的length属性不包括rest参数，例如<code>function(a, ...b){}.length  //1</code></li>
</ul>
<h4 id="数组的拓展："><a href="#数组的拓展：" class="headerlink" title="数组的拓展："></a>数组的拓展：</h4><p><code>Array.from()</code>方法，用于将类数组对象和可遍历对象转化为数组。  </p>
<ul>
<li>类数组对象：arguments，NodeList集合，及具有length的对象  </li>
<li>可遍历对象：字符串，及新增的Map和Set结构都具有Iterator接口，都可以被转化  </li>
</ul>
<h4 id="对象的拓展："><a href="#对象的拓展：" class="headerlink" title="对象的拓展："></a>对象的拓展：</h4><ul>
<li>属性简洁表示法：允许写入对象和函数作为对象的属性和方法。允许只写属性名不写属性值，这是属性值等于属性名所代表的变量，如<code>ar foo=&#39;hehe&#39;; var obj={foo}; //obj{foo:&#39;hehe&#39;}</code>  </li>
<li>属性名表达式：字面量定义时，允许表达式作为属性名，放在方括号内即可。<br>上面两者不能同时使用，否则会报错  </li>
</ul>
<p>对象方法的<code>name</code>属性，返回方法名</p>
<p><code>Object.is()</code>用来比较两个值是否严格相等，类似===，但在+0===-0及NaN===NaN上有差别。<br><strong><code>Object.assign(target, source1,sourse2...)</code></strong>，将源对象可枚举属性复制到目标对象。<br>可以用来克隆对象，<code>Object.assign({},origin)</code><br>可以用来合并多个对象，<code>Object.assign({}, ...source)</code> </p>
<blockquote>
<p>当我们调用下面的函数的时候，由于Object.assign将覆盖之前的内容，所以并不能完全的做到融合对象，而是全部替换掉，所以返回的对象内容将变成最后一个值:<code>{a: {c: 3}</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;a: &#123;b: 0&#125;&#125;, &#123;a: &#123;b: 1, c: 2&#125;&#125;, &#123;a: &#123;c: 3&#125;&#125;);</div></pre></td></tr></table></figure></p>
<p>如何深层次的融合对象，比如我们期望的输出结果为：<br><code>{a:{b:1,c:3}}</code><br>这样我们必须实现自己的算法来完成深层复制了,不过github上已经有很多好的解决方案，比如<a href="https://github.com/sindresorhus/deep-assign/blob/master/index.js" target="_blank" rel="external">deep-merge</a> 通过递归的方式逐层的去调用assign函数。   </p>
</blockquote>
<p>assigh()既不是a的浅拷贝（简单的用等号赋值）也不是a的深拷贝，而是<strong>介于两者之间</strong>——深拷贝了第一级属性。<br>Object.assign() 只是一级属性复制，<strong>比浅拷贝多拷贝了一层</strong>而已。用的时候，要注意这个问题。  </p>
<blockquote>
<p>发现一个可以简单实现深拷贝的方法，思路就是将一个对象转成json字符串，然后又将字符串转回对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function jsonClone(obj) &#123;</div><div class="line">    return JSON.parse(JSON.stringify(obj));</div><div class="line">&#125;</div><div class="line">var clone = jsonClone(&#123; a:1 &#125;);</div></pre></td></tr></table></figure>
<p><code>__proto__</code>属性，在附录中，依然是最好不要用。用<code>Object.setPropertyOf()</code>及<code>Object.getPropertyOf()</code>代替。</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol是ES6引入的一种原始数据类型，表示独一无二的值。作为属性名可以避免冲突。</p>
<h4 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h4><p>为了操作对象提供的，等同于在语言层面做出修改，属于一种“元编程”。</p>
<h4 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h4><p>非重数组及哈希</p>
<h4 id="遍历器Iterator"><a href="#遍历器Iterator" class="headerlink" title="遍历器Iterator"></a>遍历器Iterator</h4><p>它是一种接口，为各种不同的数据结构提供统一的访问机制。<br>for……o循环，作为遍历所有数据结构的统一方法，内部是调用Symbol.iterator方法实现的</p>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>一种异步编程解决方案</p>
<h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><p>用来传递异步操作的消息</p>
<h4 id="async函数与Promise及Generator的比较"><a href="#async函数与Promise及Generator的比较" class="headerlink" title="async函数与Promise及Generator的比较"></a>async函数与Promise及Generator的比较</h4><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>语法糖，class完全可以看做构造函数的另一种写法。<br>继承extends关键字实现继承，本质还是原型链实现，但写法更清晰更简单了</p>
<h4 id="修饰器Decorator"><a href="#修饰器Decorator" class="headerlink" title="修饰器Decorator"></a>修饰器Decorator</h4><p>一个表达方式，用于修改类的行为<br>MIxin模式，即混入，在一个对象中混入另一个对象的方法</p>
<h4 id="模块Module"><a href="#模块Module" class="headerlink" title="模块Module"></a>模块Module</h4><p>import，export<br>与CommonJS加载机制不同，CommonJS模块输出的是值的拷贝，ES6模块输出的是值的引用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了面试，赶紧把ES6标准入门大致翻了一下，下面是一些要点笔记，很散很浅，以后再慢慢深入学习。&lt;/p&gt;
&lt;h4 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h4&gt;&lt;p&gt;终于等
    
    </summary>
    
    
      <category term="javascript" scheme="http://allen286.github.io/tags/javascript/"/>
    
      <category term="ECMAScript 6" scheme="http://allen286.github.io/tags/ECMAScript-6/"/>
    
      <category term="ES6" scheme="http://allen286.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>闭包，上下文环境，作用域及this取值 笔记总结</title>
    <link href="http://allen286.github.io/2016/10/08/closure/"/>
    <id>http://allen286.github.io/2016/10/08/closure/</id>
    <published>2016-10-08T08:38:44.000Z</published>
    <updated>2016-10-08T08:52:16.006Z</updated>
    
    <content type="html"><![CDATA[<p>部分内容参照了<a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="external">王福朋的博客</a>，王大神深入浅出，解释的很清晰  </p>
<h3 id="1、闭包"><a href="#1、闭包" class="headerlink" title="1、闭包"></a>1、闭包</h3><h4 id="“官方”的解释："><a href="#“官方”的解释：" class="headerlink" title="“官方”的解释："></a>“官方”的解释：</h4><blockquote>
<p>闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。  </p>
</blockquote>
<p>其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。</p>
<h4 id="阮一峰："><a href="#阮一峰：" class="headerlink" title="阮一峰："></a>阮一峰：</h4><blockquote>
<p>“各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，<strong>闭包就是能够读取其他函数内部变量的函数</strong>。<br>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成<strong>定义在一个函数内部的函数</strong>。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。”</p>
</blockquote>
<h4 id="某博客："><a href="#某博客：" class="headerlink" title="某博客："></a>某博客：</h4><p>闭包是什么?闭包是Closure，这是静态语言所不具有的一个新特性。但是闭包也不是什么复杂到不可理解的东西，简而言之，闭包就是：</p>
<blockquote>
<p>  ● 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。<br>  ● 闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配<br>  ● 当在一个函数内定义另外一个函数就会产生闭包</p>
</blockquote>
<p>许多开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。<br>再说一下，因为作用域链，使得所有的函数都是闭包。这里只有一类函数除外，那就是通过Function构造器创建的函数，因为其<code>[[Scope]]</code>只包含全局对象，通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。</p>
<p>为了更好的澄清该问题，我们对ECMAScript中的闭包给出2个正确的版本定义：<br>ECMAScript中，闭包指的是：</p>
<blockquote>
<ol>
<li>从理论角度：所有的函数都是闭包。<br>因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是全局函数，函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：  </li>
</ol>
<ul>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）  </li>
<li>在代码中引用了自由变量  </li>
</ul>
</blockquote>
<h4 id="王福朋："><a href="#王福朋：" class="headerlink" title="王福朋："></a>王福朋：</h4><p>“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。<br>但是你只需要知道应用的两种情况即可——<strong>函数作为返回值，函数作为参数传递</strong>。<br>有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p>
<h4 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h4><p>闭包就是函数声明时封装的一块<strong>作用域</strong>，像气泡一样，包括了函数自己及那一时刻该作用域中的所有变量。并且，这个作用域是不是该时刻的状态快照，是一个真实的状态封装，只要闭包存在就可以对其进行修改。<br>闭包的两个关键点是：  </p>
<ol>
<li><strong>自由变</strong>量的存在   </li>
<li>函数作为<strong>返回值</strong>或作为<strong>参数</strong>传递</li>
</ol>
<p>两者本质都是<strong>跨域引用</strong>。 </p>
<h3 id="2、上下文环境"><a href="#2、上下文环境" class="headerlink" title="2、上下文环境"></a>2、上下文环境</h3><h4 id="全局代码的上下文环境数据内容为："><a href="#全局代码的上下文环境数据内容为：" class="headerlink" title="全局代码的上下文环境数据内容为："></a>全局代码的上下文环境数据内容为：</h4><p>普通变量（包括函数表达式），如： <code>var a = 10;</code> 变量声明（默认赋值为undefined）；<br><code>this</code>赋值；<br>函数声明，如： <code>function fn() { }</code>赋值；<br>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。  </p>
<p>如果代码段是<strong>函数体</strong>，那么在此基础上需要附加：<br>参数赋值<code>arguments</code>赋值，<code>自由变量</code>的取值，<code>作用域</code>赋值。</p>
<h4 id="执行上下文环境，王福朋大神给的通俗解释："><a href="#执行上下文环境，王福朋大神给的通俗解释：" class="headerlink" title="执行上下文环境，王福朋大神给的通俗解释："></a>执行上下文环境，王福朋大神给的通俗解释：</h4><blockquote>
<p> 即在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。<br>函数每被调用一次，都会产生一个新的执行上下文环境。不同的调用产生不同的上下文环境，因为不同的调用可能就会有不同的参数。</p>
</blockquote>
<h3 id="3、函数作用域"><a href="#3、函数作用域" class="headerlink" title="3、函数作用域"></a>3、函数作用域</h3><h4 id="作用域与执行上下文环境"><a href="#作用域与执行上下文环境" class="headerlink" title="作用域与执行上下文环境"></a>作用域与执行上下文环境</h4><p>除了全局作用域之外，每个函数都会创建自己的作用域。<strong>作用域在函数定义时就已经确定了，而不是在函数调用时确定。</strong><br>JS权威指南中有一句很精辟的描述:</p>
<blockquote>
<p>　”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”</p>
</blockquote>
<p>作用域只是一个“地盘”，一个==抽象的概念，其中没有变量==。要==通过作用域对应的执行上下文环境来获取变量的值==。 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。<br>所以，<strong>作用域中==变量的值==是在执行过程中产生的确定</strong>的，而<strong>作用域却是在函数创建时就确定了</strong>。</p>
<p>所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</p>
<h4 id="作用域与自由变量"><a href="#作用域与自由变量" class="headerlink" title="作用域与自由变量"></a>作用域与自由变量</h4><p>什么是自由变量？<br>如我在全局中定义了一个变量a，然后我在函数中使用了这个a，这个a就可以称之为自由变量，可以这样理解，凡是<strong>跨了自己的作用域的变量都叫自由变量</strong>。<br>函数在<strong>定义</strong>的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。<br>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“<strong>静态作用</strong>域”。</p>
<h3 id="4、函数作用域与上下文环境的区别？"><a href="#4、函数作用域与上下文环境的区别？" class="headerlink" title="4、函数作用域与上下文环境的区别？"></a>4、函数作用域与上下文环境的区别？</h3><ul>
<li><strong>00 上下文环境：</strong><br>可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？<br>另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？</li>
<li><strong>01 作用域</strong>：<br>首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。</li>
<li><strong>02 两者：</strong><br>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。  </li>
</ul>
<p>例子：闭包封装了作用域，但闭包每次执行都会产生一新的上下文环境。</p>
<blockquote>
<p>当闭包被执行，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身创建。 《高性能js》 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newClosure</span>(<span class="params">someNum, someRef</span>) </span>&#123;</div><div class="line"> <span class="comment">// Local variables that end up within closure</span></div><div class="line"> <span class="keyword">var</span> num = someNum;</div><div class="line"> <span class="keyword">var</span> anArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"> <span class="keyword">var</span> ref = someRef;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line"> num += x;</div><div class="line"> anArray.push(num);</div><div class="line"> alert(<span class="string">'num: '</span> + num +</div><div class="line"> <span class="string">'\nanArray '</span> + anArray.toString() +</div><div class="line"> <span class="string">'\nref.someVar '</span> + ref.someVar);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">closure1=newClosure(<span class="number">40</span>,&#123;<span class="attr">someVar</span>:<span class="string">'closure 1'</span>&#125;);</div><div class="line">closure2=newClosure(<span class="number">1000</span>,&#123;<span class="attr">someVar</span>:<span class="string">'closure 2'</span>&#125;);</div><div class="line">  </div><div class="line">closure1(<span class="number">5</span>); <span class="comment">// num:45 anArray[1,2,3,45] ref:'someVar closure1'</span></div><div class="line">closure2(<span class="number">-10</span>);<span class="comment">// num:990 anArray[1,2,3,990] ref:'someVar closure2'</span></div></pre></td></tr></table></figure>
<h4 id="5、this的取值"><a href="#5、this的取值" class="headerlink" title="5、this的取值"></a>5、<code>this</code>的取值</h4><p>在函数中<code>this</code>到底取何值，是在函数真正被调用<strong>执行</strong>的时候确定的，函数定义的时候确定不了。  </p>
<h5 id="情况1：构造函数"><a href="#情况1：构造函数" class="headerlink" title="情况1：构造函数"></a>情况1：构造函数</h5><p>如果函数作为构造函数用，那么其中的<code>this</code>就代表它即将<code>new出来的对象</code>。<br>在构造函数的prototype中，this代表着什么？this指向当前对象。<br>不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</p>
<h5 id="情况2：函数作为对象的一个属性"><a href="#情况2：函数作为对象的一个属性" class="headerlink" title="情况2：函数作为对象的一个属性"></a>情况2：函数作为对象的一个属性</h5><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的<code>this</code>指向<code>该对象</code>；<br><strong>注意</strong>：如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。</p>
<h5 id="情况3：函数用call或者apply调用"><a href="#情况3：函数用call或者apply调用" class="headerlink" title="情况3：函数用call或者apply调用"></a>情况3：函数用call或者apply调用</h5><p>当一个函数被<code>call</code>和<code>apply</code>调用时，<code>this</code>的值就取<code>传入的对象</code>的值。</p>
<h5 id="情况4：全局-amp-调用普通函数"><a href="#情况4：全局-amp-调用普通函数" class="headerlink" title="情况4：全局 &amp; 调用普通函数"></a>情况4：全局 &amp; 调用普通函数</h5><p>在全局环境下，<code>this</code>永远是<code>window</code>，这个应该没有非议。普通函数在调用时，其中的this也都是window。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部分内容参照了&lt;a href=&quot;http://www.cnblogs.com/wangfupeng1988/p/3977924.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;王福朋的博客&lt;/a&gt;，王大神深入浅出，解释的很清晰  &lt;/p&gt;
&lt;h3 
    
    </summary>
    
    
      <category term="javascript" scheme="http://allen286.github.io/tags/javascript/"/>
    
      <category term="笔记" scheme="http://allen286.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="闭包" scheme="http://allen286.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="作用域" scheme="http://allen286.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="原型" scheme="http://allen286.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="this取值" scheme="http://allen286.github.io/tags/this%E5%8F%96%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>布局总结（居中，多列，等高）</title>
    <link href="http://allen286.github.io/2016/10/06/layout/"/>
    <id>http://allen286.github.io/2016/10/06/layout/</id>
    <published>2016-10-06T15:10:22.000Z</published>
    <updated>2016-10-06T16:37:40.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、居中"><a href="#一、居中" class="headerlink" title="一、居中"></a>一、居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="定宽元素水平居中："><a href="#定宽元素水平居中：" class="headerlink" title="定宽元素水平居中："></a>定宽元素水平居中：</h4><p>法一：<code>margin:o auto;</code><br>法二：<code>position:relative</code>或<code>absolute</code>; <code>left:50%; margin-left:负的自身宽度一半</code>；垂直方向同理。<br>（上面两种方法都要求已知元素宽度）<br>法三：元素元素<code>text-align:center；</code>需要将子元素设置为<code>inline</code>或<code>inline-block</code>元素。<br>法四：table方法(不提倡)，水平垂直都可以。父元素<code>display: table；</code>子元素<code>display: table-cell; text-align: center; vertical-align: middle;</code>  </p>
<h4 id="不定宽元素水平居中："><a href="#不定宽元素水平居中：" class="headerlink" title="不定宽元素水平居中："></a>不定宽元素水平居中：</h4><p>1、外层元素<code>{text-align:center;}</code>，内层元素div<code>{display:inline-block;}</code>  </p>
<p>2、都<code>position: relative</code>，外层<code>left: 50%</code>，内层<code>left: -50%</code>;<br>效果是inner元素一直在wrap元素的父元素的中间位置，即inner代替wrap来包含其他内容，wrap存在意义单纯为了定位。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class="wrap"&gt;&lt;div class="inner"&gt;让 inner 居中&lt;/div&gt;&lt;/div&gt;</div><div class="line">.wrap &#123; </div><div class="line">    float: left; /* 自适应内容宽度 */    </div><div class="line">    position: relative;  left: 50%; </div><div class="line">&#125;</div><div class="line">.inner &#123; </div><div class="line">    position: relative; </div><div class="line">    left: -50%; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="垂直居中："><a href="#垂直居中：" class="headerlink" title="垂直居中："></a>垂直居中：</h3><p>1、<code>position:absolute; top:50%, margin-top:负的元素高度</code>。缺点是要已知高度才行。<br>2、<code>vertical-align:middle;</code> 只用用于inline及inline-block元素。缺点：幽灵空白<br>单行文字垂直居中直接line-height和height值相等就行<br>多行文字垂直居中同理。注：父元素font-size: 0是为了清除幽灵空白符默认的baseline对齐。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.multi-line</span>&#123;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">background-color</span>:<span class="number">#ddd</span>;<span class="attribute">line-height</span>:<span class="number">200px</span>;<span class="attribute">text-align</span>: center;<span class="attribute">font-size</span>: <span class="number">0</span>;&#125;</div><div class="line"><span class="selector-class">.multi-line</span> <span class="selector-tag">span</span>&#123;<span class="attribute">display</span>:inline-block; <span class="attribute">font-size</span>: <span class="number">16px</span>;<span class="attribute">line-height</span>:<span class="number">1.4em</span>; <span class="attribute">vertical-align</span>:middle;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="利用CSS3实现不定宽高元素水平垂直同时居中"><a href="#利用CSS3实现不定宽高元素水平垂直同时居中" class="headerlink" title="利用CSS3实现不定宽高元素水平垂直同时居中"></a>利用CSS3实现不定宽高元素水平垂直同时居中</h3><p>优点：简便且不需要知道元素宽度和高度；缺点：兼容性不好  </p>
<p>1、<code>transform : translate()</code>，IE9及以上<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">    <span class="attribute">position </span>: absolute; </div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>; <span class="attribute">left</span>: <span class="number">50%</span>; </div><div class="line">    <span class="attribute">transform </span>: <span class="built_in">translate</span>(-50%,-50%); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、<code>flex-box</code>，IE11及以上，IE10部分支持2012版本，需要-ms-前缀。<br>flex属性一直修改变化，从box(09年)到flexbox(11年)到flex(12年)，注意兼容。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attribute">display</span>:flex;  <span class="attribute">display</span>: -ms-flexbox;  <span class="comment">/* TWEENER - IE 10 */</span></div><div class="line">    <span class="attribute">justify-content</span>: center;  <span class="comment">/*主轴方向上的对齐方式，主轴方向默认水平，可通过flex-direction设置*/</span></div><div class="line">    <span class="attribute">align-items</span>: center;  <span class="comment">/*交叉轴方向上的对齐方式*/</span></div><div class="line">    <span class="comment">/*align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用*/</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、多列布局"><a href="#二、多列布局" class="headerlink" title="二、多列布局"></a>二、多列布局</h2><h3 id="两列布局，左列宽度固定，右列宽度自适应"><a href="#两列布局，左列宽度固定，右列宽度自适应" class="headerlink" title="两列布局，左列宽度固定，右列宽度自适应"></a>两列布局，左列宽度固定，右列宽度自适应</h3><p>1、左列<code>float</code>，右列<code>margin-left</code><br>2、左列<code>floa</code>，右列<code>overflow:hidden</code>（原理是触发BFC）<br>（注意：前两种方法右列一定不能设置宽度！不能写width:100%;）<br>3、外层<code>display:flex</code>，右列<code>flex:1</code> </p>
<p>两列固定比例布局就都float，宽度设置百分比；<br>CSS3中的<code>column</code>多列布局也很方便，缺点只能等宽度；  </p>
<h3 id="三列布局，左右两列宽度固定，中间一列宽度自适应"><a href="#三列布局，左右两列宽度固定，中间一列宽度自适应" class="headerlink" title="三列布局，左右两列宽度固定，中间一列宽度自适应"></a>三列布局，左右两列宽度固定，中间一列宽度自适应</h3><p>法一：html中dom结构顺序是先左右列div，再中间列div<br>左列<code>float:left</code>，右列<code>float:right</code>，中间列：设置对应的左右<code>margin</code>（或用<code>overflow:hidden</code>）  </p>
<p>法二：html中先中间div，再左右div（双飞翼布局）<br>三列全部<code>float</code>，然后左列<code>margin-left:-100%</code>，右列<code>margin-left:-自身宽度</code><br>（此法注意中间列真实宽度100%，左右列覆盖在上面，可再添加一<code>内层div，设置左右margin</code>，来保证显示区域不被左右列覆盖）</p>
<p>法三：圣杯布局（略）</p>
<p>法四：<code>flex</code>，这种最简单。左右固定<code>basis</code>如<code>100px</code>为宽度，不缩放；中间缩放为<code>1</code>。<br>同时还能设置几列固定比例，如将具体宽度设置成百分数即可(<code>20%,60%,20%</code>)。</p>
<h2 id="三、多列列自适应等高"><a href="#三、多列列自适应等高" class="headerlink" title="三、多列列自适应等高"></a>三、多列列自适应等高</h2><h5 id="让所有列与最高的那一列同高"><a href="#让所有列与最高的那一列同高" class="headerlink" title="让所有列与最高的那一列同高"></a>让所有列与最高的那一列同高</h5><p>如果其中一列的文字特别长，而其他两列很短，就有必要增加内外边距的抵消。<br>比如把较短的几列<code>内边距设置500px</code>，<code>外边距-500px</code>;就可以增加隐藏的填充部分。同时外层容器要设置<code>overflow：hidden</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、居中&quot;&gt;&lt;a href=&quot;#一、居中&quot; class=&quot;headerlink&quot; title=&quot;一、居中&quot;&gt;&lt;/a&gt;一、居中&lt;/h2&gt;&lt;h3 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; title=&quot;水平居中&quot;&gt;&lt;/a
    
    </summary>
    
    
      <category term="笔记" scheme="http://allen286.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="html" scheme="http://allen286.github.io/tags/html/"/>
    
      <category term="css" scheme="http://allen286.github.io/tags/css/"/>
    
  </entry>
  
</feed>
